<h2>Play with this demo</h2>
<p>
In this Activity, you can : 
<ul>
  <li> start a RoboAsyncTask and see the progress ;
  <li> cancel a started RoboAsyncTask ;
  <li> start a RoboAsyncTask, rotate the device and observe that UI is not updated as expected ;
  <li> simulate a memory leak by rotating the device and starting tasks.
</ul>
</p>

<p>
Read below to learn more.
</p>

<h2>RoboAsyncTask usage. </h2>

<p>
RoboAsyncTask is a class proposed by <a href="http://code.google.com/p/roboguice/wiki/RoboAsyncTask">RoboGuice</a> to solve some problems of AsyncTasks. They offer : 
<ul>
 <li> a good exception handling mechanism. You can easily get any exception that occured during asynchronous jobs.</li>
 <li> a more java 6 friendly API with respect to concurrency.</li>
</ul>
</p>

<p>
This Activity uses a simple RoboAsyncTask. <br>
</p>

<h3>Memory leak issue</h3>

<p>
RoboAsyncTask <a href="http://grepcode.com/file/repo1.maven.org/maven2/org.roboguice/roboguice/2.0/roboguice/util/RoboAsyncTask.java/">do hold a hard reference</a> on the Activity.
From there, you can understand easily that RoboAsyncTasks don't solve the memory leak issue related to AsyncTasks. 
Any RoboAsyncTask will prevent its Activity from being garbage collected. Even if RoboAsyncTasks used a WeakReference on the Activity, all Activties using them
would have to hold a WeakReference on RoboAsyncTasks and that would lead to the same bloated code as with our best implementation of AsyncTask.
</p>

<hr>
Really, we should focus on Loaders, that's what the next serie of demo Activity will be dedicated to.
